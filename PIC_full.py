# Autogenerated with SMOP version 
# main.py PIC_ES_1D_full.m
from __future__ import division
import math
import numpy as np
import scipy.sparse.linalg
import matplotlib.pyplot as plt
from scipy.sparse import spdiags
from scipy.sparse.linalg import spsolve

plt.close('all')

L=2.0 * np.pi
DT=0.1
NT=500
NTOUT=25
NG=64
N=10000
WP=1
QM=- 1
V0=0.2
VT=0.05
XP1=0.001
V1=0
mode=1
Q=WP ** 2 / (QM * N / L)
rho_back=- Q * N / L
dx=L / NG
Eg_fft=[]
temperature=[]
W_k=np.zeros(NT)
W_Egrid=np.zeros(NT)
W_Epart=np.zeros(NT)
P=np.zeros(NT)
position=[]
xp=np.linspace(0,L - L / N,N)
vp=VT * np.random.randn(N)
for i in np.arange(0,N-1):
    vp[i] = vp[i] + V0*(1-2*np.mod(i,2))
xp=xp + XP1 * np.sin(2 * np.pi * xp / L * mode)
out=np.where(xp < 0)
xp[out]=xp[out] + L
out=np.where(xp >= L)
xp[out]=xp[out] - L
Poisson = spdiags(np.array(np.ones((1,NG-1))),np.array([-1]),NG-1,NG-1) + spdiags(np.array(np.ones((1,NG-1))),np.array([1]),NG-1,NG-1) + spdiags(np.array(-2* np.ones((1,NG-1))),np.array([0]),NG-1,NG-1)

f, axarr = plt.subplots(3, sharex=False)
 
for it in np.arange(1,NT).reshape(-1):
    xp=xp + vp*DT 
    out=np.where(xp < 0)
    xp[out]=xp[out] + L
    out=np.where(xp >= L)
    xp[out]=xp[out] - L
    g1=np.floor(xp / dx - 0.5) + 1
    fraz1=1 - np.abs(xp / dx - g1 + 0.5)
    fraz2=1 - fraz1
    out=np.where(g1 < 1)
    g1[out]=g1[out] + NG
    g2=g1+1
    out=np.where(g2 > NG)
    g2[out]=g2[out] - NG
    rho=np.zeros(NG)
    for k in np.arange(0,N):
     rho[int(g1[k]-1)]=rho[int(g1[k]-1)] + fraz1[k] * (Q / dx)
     rho[int(g2[k]-1)]=rho[int(g2[k]-1)] + fraz2[k] * (Q / dx)
    rho=rho + rho_back
    Phi=spsolve(Poisson,(- rho[0:NG-1] * dx ** 2))
    Phi=np.concatenate([Phi, [0]])
    Eg = np.zeros(NG+2)
    Eg[1] = -(Phi[1] - Phi[NG-1])/ (2.0*dx)
    Eg[2:NG] = -(Phi[2:NG] - Phi[0:NG-2])/ (2.0*dx)
    Eg[NG] = -(Phi[0] - Phi[NG-2])/ (2.0*dx)
    Eg[0] = Eg[NG]
    Eg[NG+1]=Eg[1]
    Ep=np.zeros(N)
    for k in np.arange(0,N):
        Ep[k]=fraz1[k] * Eg[int(g1[k])]  + fraz2[k] * Eg[int(g2[k])]
    vp=vp + QM * Ep * DT
    
    
    P[it]=np.sum(vp)
    W_k[it]=np.sum(vp**2)
    W_Epart[it]=np.sum(Ep**2)
    W_Egrid[it]=np.sum(Eg**2)
    
    axarr[0].plot(xp[np.arange(0,N,2)], vp[np.arange(0,N,2)],'.')
    axarr[0].plot(xp[np.arange(1,N,2)], vp[np.arange(1,N,2)],'.r')
    axarr[0].set_title(it)
    axarr[0].set_ylim([-0.5,0.5])
    axarr[0].set_xlim([0,L])
    axarr[0].set_xlabel('xp')
    axarr[0].set_ylabel('vp')
    
    H,xedges,yedges = np.histogram2d(xp,vp,bins=50)
    
    axarr[1].pcolor(xedges,yedges,np.transpose(H))
    axarr[1].set_ylim([-0.5,0.5])
    axarr[1].set_xlim([0,L])
    axarr[1].set_xlabel('xp')
    axarr[1].set_ylabel('vp')

    n, bin, count = axarr[2].hist(vp, 50, normed=1, facecolor='blue', alpha=1)
    axarr[2].set_xlim([-0.5,0.5])

    plt.pause(0.001)
    axarr[0].cla()
    axarr[2].cla()
    
#    xlabel(char('xp'))
#    ylabel(char('vp'))
#    title(cat(char('T = '),num2str(it)))
#    subplot(3,1,2)
#    nXBins=100
#    nYBins=100
#    vYEdge=linspace(0,L,nYBins)
#    vXEdge=linspace(- 0.5,0.5,nXBins)
#    vXLabel=0.5 * (vXEdge(np.arange(1,(nXBins - 1))) + vXEdge(np.arange(2,nXBins)))
#    vYLabel=0.5 * (vYEdge(np.arange(1,(nYBins - 1))) + vYEdge(np.arange(2,nYBins)))
#    mHist2d=hist2d(cat(xp,vp),vYEdge,vXEdge)
#    mHist2d=mHist2d / max(max(mHist2d))
#    pcolor(vYLabel,vXLabel,log10(mHist2d.T))
#    caxis(cat(- 2,0))
#    shading(char('interp'))
#    axis(cat(0,L,- 0.5,0.5))
#    set_(gca,char('fontsize'),16)
#    xlabel(char('xp'))
#    ylabel(char('vp'))
#    subplot(3,1,3)
#    m,bin_=hist(vp,50,nargout=2)
#    bar(bin_,m / max(m),1)
#    axis(cat(- 0.5,0.5,0,1))
#    set_(gca,char('fontsize'),16)
#    xlabel(char('vp'))
#    ylabel(char('f (v)'))
#    drawnow
#    E_fft=fft(Eg) / NG
#    Eg_fft=cat([Eg_fft],[abs_(E_fft(2))])
#    temperature=cat([temperature],[std(vp)])
#    W_k=cat([W_k],[sum_(vp ** 2)])
#    W_E=cat([W_E],[sum_(Eg ** 2)])
#    P=cat([P],[sum_(vp)])
